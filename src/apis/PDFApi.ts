/* tslint:disable */
/* eslint-disable */
/**
 * API v1
 * DocSpring is a service that helps you fill out and sign PDF templates.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AddFieldsData,
  AddFieldsTemplateResponse,
  AuthenticationError,
  AuthenticationSuccessResponse,
  CombinePdfsData,
  CombinedSubmission,
  CombinedSubmissionData,
  CopyTemplateData,
  CreateCombinedSubmissionResponse,
  CreateCustomFileData,
  CreateCustomFileResponse,
  CreateFolderData,
  CreateHtmlTemplateData,
  CreateSubmissionBatchResponse,
  CreateSubmissionData,
  CreateSubmissionDataRequestTokenResponse,
  CreateSubmissionResponse,
  CreateTemplateFromUploadData,
  DeleteTemplateResponse,
  ErrorResponse,
  Folder,
  FullTemplate,
  InvalidRequest,
  ListSubmissionsResponse,
  MoveFolderData,
  MoveTemplateData,
  PendingTemplate,
  RenameFolderData,
  Submission,
  SubmissionBatch,
  SubmissionBatchData,
  SubmissionData,
  SubmissionDataRequest,
  Template,
  UpdateDataRequestResponse,
  UpdateSubmissionDataRequestData,
  UpdateTemplateData,
  UpdateTemplateResponse,
} from '../models/index';
import {
    AddFieldsDataFromJSON,
    AddFieldsDataToJSON,
    AddFieldsTemplateResponseFromJSON,
    AddFieldsTemplateResponseToJSON,
    AuthenticationErrorFromJSON,
    AuthenticationErrorToJSON,
    AuthenticationSuccessResponseFromJSON,
    AuthenticationSuccessResponseToJSON,
    CombinePdfsDataFromJSON,
    CombinePdfsDataToJSON,
    CombinedSubmissionFromJSON,
    CombinedSubmissionToJSON,
    CombinedSubmissionDataFromJSON,
    CombinedSubmissionDataToJSON,
    CopyTemplateDataFromJSON,
    CopyTemplateDataToJSON,
    CreateCombinedSubmissionResponseFromJSON,
    CreateCombinedSubmissionResponseToJSON,
    CreateCustomFileDataFromJSON,
    CreateCustomFileDataToJSON,
    CreateCustomFileResponseFromJSON,
    CreateCustomFileResponseToJSON,
    CreateFolderDataFromJSON,
    CreateFolderDataToJSON,
    CreateHtmlTemplateDataFromJSON,
    CreateHtmlTemplateDataToJSON,
    CreateSubmissionBatchResponseFromJSON,
    CreateSubmissionBatchResponseToJSON,
    CreateSubmissionDataFromJSON,
    CreateSubmissionDataToJSON,
    CreateSubmissionDataRequestTokenResponseFromJSON,
    CreateSubmissionDataRequestTokenResponseToJSON,
    CreateSubmissionResponseFromJSON,
    CreateSubmissionResponseToJSON,
    CreateTemplateFromUploadDataFromJSON,
    CreateTemplateFromUploadDataToJSON,
    DeleteTemplateResponseFromJSON,
    DeleteTemplateResponseToJSON,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    FolderFromJSON,
    FolderToJSON,
    FullTemplateFromJSON,
    FullTemplateToJSON,
    InvalidRequestFromJSON,
    InvalidRequestToJSON,
    ListSubmissionsResponseFromJSON,
    ListSubmissionsResponseToJSON,
    MoveFolderDataFromJSON,
    MoveFolderDataToJSON,
    MoveTemplateDataFromJSON,
    MoveTemplateDataToJSON,
    PendingTemplateFromJSON,
    PendingTemplateToJSON,
    RenameFolderDataFromJSON,
    RenameFolderDataToJSON,
    SubmissionFromJSON,
    SubmissionToJSON,
    SubmissionBatchFromJSON,
    SubmissionBatchToJSON,
    SubmissionBatchDataFromJSON,
    SubmissionBatchDataToJSON,
    SubmissionDataFromJSON,
    SubmissionDataToJSON,
    SubmissionDataRequestFromJSON,
    SubmissionDataRequestToJSON,
    TemplateFromJSON,
    TemplateToJSON,
    UpdateDataRequestResponseFromJSON,
    UpdateDataRequestResponseToJSON,
    UpdateSubmissionDataRequestDataFromJSON,
    UpdateSubmissionDataRequestDataToJSON,
    UpdateTemplateDataFromJSON,
    UpdateTemplateDataToJSON,
    UpdateTemplateResponseFromJSON,
    UpdateTemplateResponseToJSON,
} from '../models/index';

export interface AddFieldsToTemplateRequest {
    templateId: string;
    data: AddFieldsData;
}

export interface BatchGeneratePdfV1Request {
    templateId: string;
    data: Array<SubmissionData>;
}

export interface BatchGeneratePdfsRequest {
    data: SubmissionBatchData;
}

export interface CombinePdfsRequest {
    data: CombinePdfsData;
}

export interface CombineSubmissionsRequest {
    data: CombinedSubmissionData;
}

export interface CopyTemplateRequest {
    templateId: string;
    data?: CopyTemplateData;
}

export interface CreateCustomFileFromUploadRequest {
    data: CreateCustomFileData;
}

export interface CreateDataRequestTokenRequest {
    dataRequestId: string;
}

export interface CreateFolderRequest {
    data: CreateFolderData;
}

export interface CreateHTMLTemplateRequest {
    data: CreateHtmlTemplateData;
}

export interface CreatePDFTemplateRequest {
    templateDocument: Blob;
    templateName: string;
    templateParentFolderId?: string;
}

export interface CreatePDFTemplateFromUploadRequest {
    data: CreateTemplateFromUploadData;
}

export interface DeleteFolderRequest {
    folderId: string;
}

export interface DeleteTemplateRequest {
    templateId: string;
}

export interface ExpireCombinedSubmissionRequest {
    combinedSubmissionId: string;
}

export interface ExpireSubmissionRequest {
    submissionId: string;
}

export interface GeneratePDFRequest {
    templateId: string;
    submission: CreateSubmissionData;
}

export interface GetCombinedSubmissionRequest {
    combinedSubmissionId: string;
}

export interface GetDataRequestRequest {
    dataRequestId: string;
}

export interface GetFullTemplateRequest {
    templateId: string;
}

export interface GetSubmissionRequest {
    submissionId: string;
    includeData?: boolean;
}

export interface GetSubmissionBatchRequest {
    submissionBatchId: string;
    includeSubmissions?: boolean;
}

export interface GetTemplateRequest {
    templateId: string;
}

export interface GetTemplateSchemaRequest {
    templateId: string;
}

export interface ListCombinedSubmissionsRequest {
    page?: number;
    perPage?: number;
}

export interface ListFoldersRequest {
    parentFolderId?: string;
}

export interface ListSubmissionsRequest {
    cursor?: string;
    limit?: number;
    createdAfter?: string;
    createdBefore?: string;
    type?: string;
    includeData?: boolean;
}

export interface ListTemplateSubmissionsRequest {
    templateId: string;
    cursor?: string;
    limit?: number;
    createdAfter?: string;
    createdBefore?: string;
    type?: string;
    includeData?: boolean;
}

export interface ListTemplatesRequest {
    query?: string;
    parentFolderId?: string;
    page?: number;
    perPage?: number;
}

export interface MoveFolderToFolderRequest {
    folderId: string;
    data: MoveFolderData;
}

export interface MoveTemplateToFolderRequest {
    templateId: string;
    data: MoveTemplateData;
}

export interface RenameFolderRequest {
    folderId: string;
    data: RenameFolderData;
}

export interface UpdateDataRequestRequest {
    dataRequestId: string;
    data: UpdateSubmissionDataRequestData;
}

export interface UpdateTemplateRequest {
    templateId: string;
    data: UpdateTemplateData;
}

/**
 * 
 */
export class PDFApi extends runtime.BaseAPI {

    /**
     * Add new fields to a Template
     */
    async addFieldsToTemplateRaw(requestParameters: AddFieldsToTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AddFieldsTemplateResponse>> {
        if (requestParameters.templateId === null || requestParameters.templateId === undefined) {
            throw new runtime.RequiredError('templateId','Required parameter requestParameters.templateId was null or undefined when calling addFieldsToTemplate.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling addFieldsToTemplate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/templates/{template_id}/add_fields`.replace(`{${"template_id"}}`, encodeURIComponent(String(requestParameters.templateId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AddFieldsDataToJSON(requestParameters.data),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AddFieldsTemplateResponseFromJSON(jsonValue));
    }

    /**
     * Add new fields to a Template
     */
    async addFieldsToTemplate(requestParameters: AddFieldsToTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AddFieldsTemplateResponse> {
        const response = await this.addFieldsToTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generates multiple PDFs
     */
    async batchGeneratePdfV1Raw(requestParameters: BatchGeneratePdfV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CreateSubmissionResponse>>> {
        if (requestParameters.templateId === null || requestParameters.templateId === undefined) {
            throw new runtime.RequiredError('templateId','Required parameter requestParameters.templateId was null or undefined when calling batchGeneratePdfV1.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling batchGeneratePdfV1.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/templates/{template_id}/submissions/batch`.replace(`{${"template_id"}}`, encodeURIComponent(String(requestParameters.templateId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.data.map(SubmissionDataToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CreateSubmissionResponseFromJSON));
    }

    /**
     * Generates multiple PDFs
     */
    async batchGeneratePdfV1(requestParameters: BatchGeneratePdfV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CreateSubmissionResponse>> {
        const response = await this.batchGeneratePdfV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generates multiple PDFs
     */
    async batchGeneratePdfsRaw(requestParameters: BatchGeneratePdfsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateSubmissionBatchResponse>> {
        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling batchGeneratePdfs.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/submissions/batches`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SubmissionBatchDataToJSON(requestParameters.data),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateSubmissionBatchResponseFromJSON(jsonValue));
    }

    /**
     * Generates multiple PDFs
     */
    async batchGeneratePdfs(requestParameters: BatchGeneratePdfsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateSubmissionBatchResponse> {
        const response = await this.batchGeneratePdfsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Merge submission PDFs, template PDFs, or custom files
     */
    async combinePdfsRaw(requestParameters: CombinePdfsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateCombinedSubmissionResponse>> {
        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling combinePdfs.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/combined_submissions?v=2`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CombinePdfsDataToJSON(requestParameters.data),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateCombinedSubmissionResponseFromJSON(jsonValue));
    }

    /**
     * Merge submission PDFs, template PDFs, or custom files
     */
    async combinePdfs(requestParameters: CombinePdfsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateCombinedSubmissionResponse> {
        const response = await this.combinePdfsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Merge generated PDFs together
     */
    async combineSubmissionsRaw(requestParameters: CombineSubmissionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateCombinedSubmissionResponse>> {
        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling combineSubmissions.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/combined_submissions`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CombinedSubmissionDataToJSON(requestParameters.data),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateCombinedSubmissionResponseFromJSON(jsonValue));
    }

    /**
     * Merge generated PDFs together
     */
    async combineSubmissions(requestParameters: CombineSubmissionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateCombinedSubmissionResponse> {
        const response = await this.combineSubmissionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Copy a Template
     */
    async copyTemplateRaw(requestParameters: CopyTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Template>> {
        if (requestParameters.templateId === null || requestParameters.templateId === undefined) {
            throw new runtime.RequiredError('templateId','Required parameter requestParameters.templateId was null or undefined when calling copyTemplate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/templates/{template_id}/copy`.replace(`{${"template_id"}}`, encodeURIComponent(String(requestParameters.templateId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CopyTemplateDataToJSON(requestParameters.data),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TemplateFromJSON(jsonValue));
    }

    /**
     * Copy a Template
     */
    async copyTemplate(requestParameters: CopyTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Template> {
        const response = await this.copyTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new custom file from a cached presign upload
     */
    async createCustomFileFromUploadRaw(requestParameters: CreateCustomFileFromUploadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateCustomFileResponse>> {
        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createCustomFileFromUpload.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/custom_files`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateCustomFileDataToJSON(requestParameters.data),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateCustomFileResponseFromJSON(jsonValue));
    }

    /**
     * Create a new custom file from a cached presign upload
     */
    async createCustomFileFromUpload(requestParameters: CreateCustomFileFromUploadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateCustomFileResponse> {
        const response = await this.createCustomFileFromUploadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new data request token for form authentication
     */
    async createDataRequestTokenRaw(requestParameters: CreateDataRequestTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateSubmissionDataRequestTokenResponse>> {
        if (requestParameters.dataRequestId === null || requestParameters.dataRequestId === undefined) {
            throw new runtime.RequiredError('dataRequestId','Required parameter requestParameters.dataRequestId was null or undefined when calling createDataRequestToken.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/data_requests/{data_request_id}/tokens`.replace(`{${"data_request_id"}}`, encodeURIComponent(String(requestParameters.dataRequestId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateSubmissionDataRequestTokenResponseFromJSON(jsonValue));
    }

    /**
     * Creates a new data request token for form authentication
     */
    async createDataRequestToken(requestParameters: CreateDataRequestTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateSubmissionDataRequestTokenResponse> {
        const response = await this.createDataRequestTokenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a folder
     */
    async createFolderRaw(requestParameters: CreateFolderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Folder>> {
        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createFolder.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/folders/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateFolderDataToJSON(requestParameters.data),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FolderFromJSON(jsonValue));
    }

    /**
     * Create a folder
     */
    async createFolder(requestParameters: CreateFolderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Folder> {
        const response = await this.createFolderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new HTML template
     */
    async createHTMLTemplateRaw(requestParameters: CreateHTMLTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PendingTemplate>> {
        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createHTMLTemplate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/templates?desc=html`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateHtmlTemplateDataToJSON(requestParameters.data),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PendingTemplateFromJSON(jsonValue));
    }

    /**
     * Create a new HTML template
     */
    async createHTMLTemplate(requestParameters: CreateHTMLTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PendingTemplate> {
        const response = await this.createHTMLTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new PDF template with a form POST file upload
     */
    async createPDFTemplateRaw(requestParameters: CreatePDFTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PendingTemplate>> {
        if (requestParameters.templateDocument === null || requestParameters.templateDocument === undefined) {
            throw new runtime.RequiredError('templateDocument','Required parameter requestParameters.templateDocument was null or undefined when calling createPDFTemplate.');
        }

        if (requestParameters.templateName === null || requestParameters.templateName === undefined) {
            throw new runtime.RequiredError('templateName','Required parameter requestParameters.templateName was null or undefined when calling createPDFTemplate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.templateDocument !== undefined) {
            formParams.append('template[document]', requestParameters.templateDocument as any);
        }

        if (requestParameters.templateName !== undefined) {
            formParams.append('template[name]', requestParameters.templateName as any);
        }

        if (requestParameters.templateParentFolderId !== undefined) {
            formParams.append('template[parent_folder_id]', requestParameters.templateParentFolderId as any);
        }

        const response = await this.request({
            path: `/templates`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PendingTemplateFromJSON(jsonValue));
    }

    /**
     * Create a new PDF template with a form POST file upload
     */
    async createPDFTemplate(requestParameters: CreatePDFTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PendingTemplate> {
        const response = await this.createPDFTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new PDF template from a cached presign upload
     */
    async createPDFTemplateFromUploadRaw(requestParameters: CreatePDFTemplateFromUploadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PendingTemplate>> {
        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createPDFTemplateFromUpload.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/templates?desc=cached_upload`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateTemplateFromUploadDataToJSON(requestParameters.data),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PendingTemplateFromJSON(jsonValue));
    }

    /**
     * Create a new PDF template from a cached presign upload
     */
    async createPDFTemplateFromUpload(requestParameters: CreatePDFTemplateFromUploadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PendingTemplate> {
        const response = await this.createPDFTemplateFromUploadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a folder
     */
    async deleteFolderRaw(requestParameters: DeleteFolderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Folder>> {
        if (requestParameters.folderId === null || requestParameters.folderId === undefined) {
            throw new runtime.RequiredError('folderId','Required parameter requestParameters.folderId was null or undefined when calling deleteFolder.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/folders/{folder_id}`.replace(`{${"folder_id"}}`, encodeURIComponent(String(requestParameters.folderId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FolderFromJSON(jsonValue));
    }

    /**
     * Delete a folder
     */
    async deleteFolder(requestParameters: DeleteFolderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Folder> {
        const response = await this.deleteFolderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a template
     */
    async deleteTemplateRaw(requestParameters: DeleteTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteTemplateResponse>> {
        if (requestParameters.templateId === null || requestParameters.templateId === undefined) {
            throw new runtime.RequiredError('templateId','Required parameter requestParameters.templateId was null or undefined when calling deleteTemplate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/templates/{template_id}`.replace(`{${"template_id"}}`, encodeURIComponent(String(requestParameters.templateId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeleteTemplateResponseFromJSON(jsonValue));
    }

    /**
     * Delete a template
     */
    async deleteTemplate(requestParameters: DeleteTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteTemplateResponse> {
        const response = await this.deleteTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Expire a combined submission
     */
    async expireCombinedSubmissionRaw(requestParameters: ExpireCombinedSubmissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CombinedSubmission>> {
        if (requestParameters.combinedSubmissionId === null || requestParameters.combinedSubmissionId === undefined) {
            throw new runtime.RequiredError('combinedSubmissionId','Required parameter requestParameters.combinedSubmissionId was null or undefined when calling expireCombinedSubmission.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/combined_submissions/{combined_submission_id}`.replace(`{${"combined_submission_id"}}`, encodeURIComponent(String(requestParameters.combinedSubmissionId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CombinedSubmissionFromJSON(jsonValue));
    }

    /**
     * Expire a combined submission
     */
    async expireCombinedSubmission(requestParameters: ExpireCombinedSubmissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CombinedSubmission> {
        const response = await this.expireCombinedSubmissionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Expire a PDF submission
     */
    async expireSubmissionRaw(requestParameters: ExpireSubmissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Submission>> {
        if (requestParameters.submissionId === null || requestParameters.submissionId === undefined) {
            throw new runtime.RequiredError('submissionId','Required parameter requestParameters.submissionId was null or undefined when calling expireSubmission.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/submissions/{submission_id}`.replace(`{${"submission_id"}}`, encodeURIComponent(String(requestParameters.submissionId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubmissionFromJSON(jsonValue));
    }

    /**
     * Expire a PDF submission
     */
    async expireSubmission(requestParameters: ExpireSubmissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Submission> {
        const response = await this.expireSubmissionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generates a new PDF
     */
    async generatePDFRaw(requestParameters: GeneratePDFRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateSubmissionResponse>> {
        if (requestParameters.templateId === null || requestParameters.templateId === undefined) {
            throw new runtime.RequiredError('templateId','Required parameter requestParameters.templateId was null or undefined when calling generatePDF.');
        }

        if (requestParameters.submission === null || requestParameters.submission === undefined) {
            throw new runtime.RequiredError('submission','Required parameter requestParameters.submission was null or undefined when calling generatePDF.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/templates/{template_id}/submissions`.replace(`{${"template_id"}}`, encodeURIComponent(String(requestParameters.templateId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateSubmissionDataToJSON(requestParameters.submission),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateSubmissionResponseFromJSON(jsonValue));
    }

    /**
     * Generates a new PDF
     */
    async generatePDF(requestParameters: GeneratePDFRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateSubmissionResponse> {
        const response = await this.generatePDFRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Check the status of a combined submission (merged PDFs)
     */
    async getCombinedSubmissionRaw(requestParameters: GetCombinedSubmissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CombinedSubmission>> {
        if (requestParameters.combinedSubmissionId === null || requestParameters.combinedSubmissionId === undefined) {
            throw new runtime.RequiredError('combinedSubmissionId','Required parameter requestParameters.combinedSubmissionId was null or undefined when calling getCombinedSubmission.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/combined_submissions/{combined_submission_id}`.replace(`{${"combined_submission_id"}}`, encodeURIComponent(String(requestParameters.combinedSubmissionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CombinedSubmissionFromJSON(jsonValue));
    }

    /**
     * Check the status of a combined submission (merged PDFs)
     */
    async getCombinedSubmission(requestParameters: GetCombinedSubmissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CombinedSubmission> {
        const response = await this.getCombinedSubmissionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Look up a submission data request
     */
    async getDataRequestRaw(requestParameters: GetDataRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SubmissionDataRequest>> {
        if (requestParameters.dataRequestId === null || requestParameters.dataRequestId === undefined) {
            throw new runtime.RequiredError('dataRequestId','Required parameter requestParameters.dataRequestId was null or undefined when calling getDataRequest.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/data_requests/{data_request_id}`.replace(`{${"data_request_id"}}`, encodeURIComponent(String(requestParameters.dataRequestId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubmissionDataRequestFromJSON(jsonValue));
    }

    /**
     * Look up a submission data request
     */
    async getDataRequest(requestParameters: GetDataRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SubmissionDataRequest> {
        const response = await this.getDataRequestRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch the full template attributes
     */
    async getFullTemplateRaw(requestParameters: GetFullTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullTemplate>> {
        if (requestParameters.templateId === null || requestParameters.templateId === undefined) {
            throw new runtime.RequiredError('templateId','Required parameter requestParameters.templateId was null or undefined when calling getFullTemplate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/templates/{template_id}?full=true`.replace(`{${"template_id"}}`, encodeURIComponent(String(requestParameters.templateId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullTemplateFromJSON(jsonValue));
    }

    /**
     * Fetch the full template attributes
     */
    async getFullTemplate(requestParameters: GetFullTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullTemplate> {
        const response = await this.getFullTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a presigned URL so that you can upload a file to our AWS S3 bucket
     */
    async getPresignUrlRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/uploads/presign`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get a presigned URL so that you can upload a file to our AWS S3 bucket
     */
    async getPresignUrl(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.getPresignUrlRaw(initOverrides);
        return await response.value();
    }

    /**
     * Check the status of a PDF
     */
    async getSubmissionRaw(requestParameters: GetSubmissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Submission>> {
        if (requestParameters.submissionId === null || requestParameters.submissionId === undefined) {
            throw new runtime.RequiredError('submissionId','Required parameter requestParameters.submissionId was null or undefined when calling getSubmission.');
        }

        const queryParameters: any = {};

        if (requestParameters.includeData !== undefined) {
            queryParameters['include_data'] = requestParameters.includeData;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/submissions/{submission_id}`.replace(`{${"submission_id"}}`, encodeURIComponent(String(requestParameters.submissionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubmissionFromJSON(jsonValue));
    }

    /**
     * Check the status of a PDF
     */
    async getSubmission(requestParameters: GetSubmissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Submission> {
        const response = await this.getSubmissionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Check the status of a submission batch job
     */
    async getSubmissionBatchRaw(requestParameters: GetSubmissionBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SubmissionBatch>> {
        if (requestParameters.submissionBatchId === null || requestParameters.submissionBatchId === undefined) {
            throw new runtime.RequiredError('submissionBatchId','Required parameter requestParameters.submissionBatchId was null or undefined when calling getSubmissionBatch.');
        }

        const queryParameters: any = {};

        if (requestParameters.includeSubmissions !== undefined) {
            queryParameters['include_submissions'] = requestParameters.includeSubmissions;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/submissions/batches/{submission_batch_id}`.replace(`{${"submission_batch_id"}}`, encodeURIComponent(String(requestParameters.submissionBatchId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubmissionBatchFromJSON(jsonValue));
    }

    /**
     * Check the status of a submission batch job
     */
    async getSubmissionBatch(requestParameters: GetSubmissionBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SubmissionBatch> {
        const response = await this.getSubmissionBatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Check the status of an uploaded template
     */
    async getTemplateRaw(requestParameters: GetTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Template>> {
        if (requestParameters.templateId === null || requestParameters.templateId === undefined) {
            throw new runtime.RequiredError('templateId','Required parameter requestParameters.templateId was null or undefined when calling getTemplate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/templates/{template_id}`.replace(`{${"template_id"}}`, encodeURIComponent(String(requestParameters.templateId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TemplateFromJSON(jsonValue));
    }

    /**
     * Check the status of an uploaded template
     */
    async getTemplate(requestParameters: GetTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Template> {
        const response = await this.getTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch the JSON schema for a template
     */
    async getTemplateSchemaRaw(requestParameters: GetTemplateSchemaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.templateId === null || requestParameters.templateId === undefined) {
            throw new runtime.RequiredError('templateId','Required parameter requestParameters.templateId was null or undefined when calling getTemplateSchema.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/templates/{template_id}/schema`.replace(`{${"template_id"}}`, encodeURIComponent(String(requestParameters.templateId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Fetch the JSON schema for a template
     */
    async getTemplateSchema(requestParameters: GetTemplateSchemaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.getTemplateSchemaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all combined submissions
     */
    async listCombinedSubmissionsRaw(requestParameters: ListCombinedSubmissionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CombinedSubmission>>> {
        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.perPage !== undefined) {
            queryParameters['per_page'] = requestParameters.perPage;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/combined_submissions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CombinedSubmissionFromJSON));
    }

    /**
     * Get a list of all combined submissions
     */
    async listCombinedSubmissions(requestParameters: ListCombinedSubmissionsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CombinedSubmission>> {
        const response = await this.listCombinedSubmissionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all folders
     */
    async listFoldersRaw(requestParameters: ListFoldersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Folder>>> {
        const queryParameters: any = {};

        if (requestParameters.parentFolderId !== undefined) {
            queryParameters['parent_folder_id'] = requestParameters.parentFolderId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/folders/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FolderFromJSON));
    }

    /**
     * Get a list of all folders
     */
    async listFolders(requestParameters: ListFoldersRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Folder>> {
        const response = await this.listFoldersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all submissions
     */
    async listSubmissionsRaw(requestParameters: ListSubmissionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListSubmissionsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.cursor !== undefined) {
            queryParameters['cursor'] = requestParameters.cursor;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.createdAfter !== undefined) {
            queryParameters['created_after'] = requestParameters.createdAfter;
        }

        if (requestParameters.createdBefore !== undefined) {
            queryParameters['created_before'] = requestParameters.createdBefore;
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.includeData !== undefined) {
            queryParameters['include_data'] = requestParameters.includeData;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/submissions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListSubmissionsResponseFromJSON(jsonValue));
    }

    /**
     * List all submissions
     */
    async listSubmissions(requestParameters: ListSubmissionsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListSubmissionsResponse> {
        const response = await this.listSubmissionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all submissions for a given template
     */
    async listTemplateSubmissionsRaw(requestParameters: ListTemplateSubmissionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListSubmissionsResponse>> {
        if (requestParameters.templateId === null || requestParameters.templateId === undefined) {
            throw new runtime.RequiredError('templateId','Required parameter requestParameters.templateId was null or undefined when calling listTemplateSubmissions.');
        }

        const queryParameters: any = {};

        if (requestParameters.cursor !== undefined) {
            queryParameters['cursor'] = requestParameters.cursor;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.createdAfter !== undefined) {
            queryParameters['created_after'] = requestParameters.createdAfter;
        }

        if (requestParameters.createdBefore !== undefined) {
            queryParameters['created_before'] = requestParameters.createdBefore;
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.includeData !== undefined) {
            queryParameters['include_data'] = requestParameters.includeData;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/templates/{template_id}/submissions`.replace(`{${"template_id"}}`, encodeURIComponent(String(requestParameters.templateId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListSubmissionsResponseFromJSON(jsonValue));
    }

    /**
     * List all submissions for a given template
     */
    async listTemplateSubmissions(requestParameters: ListTemplateSubmissionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListSubmissionsResponse> {
        const response = await this.listTemplateSubmissionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all templates
     */
    async listTemplatesRaw(requestParameters: ListTemplatesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Template>>> {
        const queryParameters: any = {};

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.parentFolderId !== undefined) {
            queryParameters['parent_folder_id'] = requestParameters.parentFolderId;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.perPage !== undefined) {
            queryParameters['per_page'] = requestParameters.perPage;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/templates`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TemplateFromJSON));
    }

    /**
     * Get a list of all templates
     */
    async listTemplates(requestParameters: ListTemplatesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Template>> {
        const response = await this.listTemplatesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Move a folder
     */
    async moveFolderToFolderRaw(requestParameters: MoveFolderToFolderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Folder>> {
        if (requestParameters.folderId === null || requestParameters.folderId === undefined) {
            throw new runtime.RequiredError('folderId','Required parameter requestParameters.folderId was null or undefined when calling moveFolderToFolder.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling moveFolderToFolder.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/folders/{folder_id}/move`.replace(`{${"folder_id"}}`, encodeURIComponent(String(requestParameters.folderId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MoveFolderDataToJSON(requestParameters.data),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FolderFromJSON(jsonValue));
    }

    /**
     * Move a folder
     */
    async moveFolderToFolder(requestParameters: MoveFolderToFolderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Folder> {
        const response = await this.moveFolderToFolderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Move Template to folder
     */
    async moveTemplateToFolderRaw(requestParameters: MoveTemplateToFolderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Template>> {
        if (requestParameters.templateId === null || requestParameters.templateId === undefined) {
            throw new runtime.RequiredError('templateId','Required parameter requestParameters.templateId was null or undefined when calling moveTemplateToFolder.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling moveTemplateToFolder.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/templates/{template_id}/move`.replace(`{${"template_id"}}`, encodeURIComponent(String(requestParameters.templateId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MoveTemplateDataToJSON(requestParameters.data),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TemplateFromJSON(jsonValue));
    }

    /**
     * Move Template to folder
     */
    async moveTemplateToFolder(requestParameters: MoveTemplateToFolderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Template> {
        const response = await this.moveTemplateToFolderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Rename a folder
     */
    async renameFolderRaw(requestParameters: RenameFolderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.folderId === null || requestParameters.folderId === undefined) {
            throw new runtime.RequiredError('folderId','Required parameter requestParameters.folderId was null or undefined when calling renameFolder.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling renameFolder.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/folders/{folder_id}/rename`.replace(`{${"folder_id"}}`, encodeURIComponent(String(requestParameters.folderId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RenameFolderDataToJSON(requestParameters.data),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Rename a folder
     */
    async renameFolder(requestParameters: RenameFolderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.renameFolderRaw(requestParameters, initOverrides);
    }

    /**
     * Test Authentication
     */
    async testAuthenticationRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthenticationSuccessResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/authentication`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthenticationSuccessResponseFromJSON(jsonValue));
    }

    /**
     * Test Authentication
     */
    async testAuthentication(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthenticationSuccessResponse> {
        const response = await this.testAuthenticationRaw(initOverrides);
        return await response.value();
    }

    /**
     * Update a submission data request
     */
    async updateDataRequestRaw(requestParameters: UpdateDataRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateDataRequestResponse>> {
        if (requestParameters.dataRequestId === null || requestParameters.dataRequestId === undefined) {
            throw new runtime.RequiredError('dataRequestId','Required parameter requestParameters.dataRequestId was null or undefined when calling updateDataRequest.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateDataRequest.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/data_requests/{data_request_id}`.replace(`{${"data_request_id"}}`, encodeURIComponent(String(requestParameters.dataRequestId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateSubmissionDataRequestDataToJSON(requestParameters.data),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateDataRequestResponseFromJSON(jsonValue));
    }

    /**
     * Update a submission data request
     */
    async updateDataRequest(requestParameters: UpdateDataRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateDataRequestResponse> {
        const response = await this.updateDataRequestRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a Template
     */
    async updateTemplateRaw(requestParameters: UpdateTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateTemplateResponse>> {
        if (requestParameters.templateId === null || requestParameters.templateId === undefined) {
            throw new runtime.RequiredError('templateId','Required parameter requestParameters.templateId was null or undefined when calling updateTemplate.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateTemplate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/templates/{template_id}`.replace(`{${"template_id"}}`, encodeURIComponent(String(requestParameters.templateId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateTemplateDataToJSON(requestParameters.data),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateTemplateResponseFromJSON(jsonValue));
    }

    /**
     * Update a Template
     */
    async updateTemplate(requestParameters: UpdateTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateTemplateResponse> {
        const response = await this.updateTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
